#include <iostream>
#include <cerrno>
#include <cstring>
#include <cassert>
#include <winsock2.h>
#include <ws2tcpip.h>
#include <vector>
#include <unordered_map>
#pragma comment(lib, "ws2_32.lib")

using namespace std;


static void msg(const char *msg){
  fprintf(stderr, "%s\n",msg);
}

static void msg_errno(const char *msg){
  fprintf(stderr, "[erron: %d] %s\n",errno,msg);
}

// 添加错误处理函数
static void die(const char *msg) {
    int err = WSAGetLastError();
    fprintf(stderr, "[%d] %s\n", err, msg);
    WSACleanup();
    exit(1);
}

static void fd_set_nb(int fd){
  errno = 0;
  int flags = fcntl(fd,F_GETFL,0);
  if(errno != 0){
    die("fcntl() erron");
    return;

  }
  flags |= O_NONBLOCK;
  errno = 0;
  (void)fcntl(fd,F_SETFL,flags);
  if (errno != 0)
  {
    die("fcntl() erron");
    /* code */
  }
  
}

const size_t k_max_msg = 32 << 20;

struct Conn{
  int fd;

  bool want_read = false;
  bool want_write = false;
  bool want_close =  false;

  std::vector<uint8_t> incoming; // data to be parsed by the application
  std::vector<uint8_t> outgoing; // response generated by the application
};

static void buf_append(std::vector<uint8_t> &buf,const uint8_t *data,size_t n){
  buf.insert(buf.end(),data,data+len);
};

static void buf_consume(std::vector<uint8_t> &buf,size_t n){
  buf.erase(buf.begin(),buf.begin()+n);
};

static Conn* handle_accept(int fd){
  //accept 
  struct sockaddr_in client_addr = {};
  socklen_t addrlen = sizeof(client_addr);
  int connfd = accept(fd,(struct sockaddr*)&client_addr, &addrlen);
  if(connfd < 0){
    msg_errno("accept()");
    return nullptr;
  }
  uint32_t ip = ntohl(client_addr.sin_addr.s_addr); // ipv4, use ntohs to convert to host byte order that prevents big-endian or little-endian issues
  fprintf(stderr,
    "new client from %u.%u.%u.%u:%u\n",
    (ip >> 24) & 255,
    (ip >> 16) & 255,
    (ip >> 8) & 255,
    ip & 255, 
    ntohs(client_addr.sin_port)) // the same goes for ipv4 above

    // set non-blocking
    fd_set_nb(connfd);

    //creat a struct Conn
    Conn* conn = new Conn();
    conn->fd = connfd;
    conn->want_read = true;
    return conn;
};

// process 1 request if there is enough data
static void try_one_requests(Conn* conn){
  // try to parse the protocol : message header
  if(conn->incoming.size() < 4) return false; // want read
  uint32_t len = 0;
  memcpy(&len,conn->incoming.data(),4);

  if(len > k_max_msg){
    msg("message too long");
    conn->want_close = true;
    return false;
  }
  if(4+len > conn->incoming.size()) return false; // data is not enough that this isn't a complete message
  const uint8_t* request = &conn->incoming[4];
  printf("client request: len: %d data: %s\n",len,len < 100 ? len:100,request);

  // generate the response(echo)
  buf_append(conn->outgoing,(const uint8_t *)&len,4);
  buf_append(conn->outgoing,request,len);

  // application logic done! remove the request message
  buf_consume(conn->incoming,4+len);

  return true;
}

static void handle_write(Conn* conn){
  assert(conn->outgoing.size()>0);

  ssize_t rv = write(conn->fd,conn->outgoing.data(),conn->outgoing.size());
  if(rv<0 && errno == EAGAIN) return; // EAGAIN: no data to write that not ready
  if(rv<0){
    msg_errno("write() error");
    conn->want_close = true;
    return;
  }

  // remove written data
  buf_consume(conn->outgoing,(size_t)rv);
  if(conn->outgoing.size()==0){
    conn->want_read = true;
    conn->want_write = false;
  }
}

static void handle_read(Conn* conn){
  uint8_t buf[64 * 1024];
  ssize_t rv = read(conn->fd, buf,sizeof(buf));
  if(rv < 0 && errno != EAGAIN) return ;
  if(rv==0){
    if(conn->incoming.size()==0){
      msg("Connection closed");
    }else{
      msg("unexpected EOF");
    }

    conn->want_close = true;
    return ;
  }

  buf_append(conn->incoming,buf,(size_t)rv);

  while(try_one_requests(conn)){}

  if(conn->outgoing.size()>0){
    conn->want_write = true;
    conn->want_read = false;

    return handle_write(conn);
  }
}

int main() {
  // 初始化Winsock
  WSADATA wsaData;
  if (WSAStartup(MAKEWORD(2,2), &wsaData) != 0) {
    std::cerr << "WSAStartup failed" << std::endl;
    return 1;
  }

  // std::cout << "Hello, Redis!" << std::endl;
  int fd = socket(AF_INET, SOCK_STREAM, 0);
  if (fd < 0) {
      die("socket()");
  }

  // 设置服务器地址和端口
  struct sockaddr_in addr = {};
  addr.sin_family = AF_INET;
  addr.sin_port = htons(6379);
  addr.sin_addr.s_addr = htonl(INADDR_ANY);  // 绑定到所有可用接口

  // 设置套接字选项，允许地址重用
  int opt = 1;
  if (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (const char*)&opt, sizeof(opt)) < 0) {
      die("setsockopt(SO_REUSEADDR) failed");
  }

  int rv = bind(fd, (const struct sockaddr*)&addr, sizeof(addr));
  if (rv) { 
      die("bind()");
  }

  rv = listen(fd, 4096);
  if (rv){ die("listen()");}


  std::cout << "Server listening on port 6379..." << std::endl;

  // std::vector<Conn *> fd2conn;
  std::unordered_map<int, Conn*> fd2conn_map;
  std::vector<struct pollfd> poll_args;

  while(true){
    poll_args.clear();
    // put the listening socket into pollfds in the beginning
    struct pollfd pfd = {fd, POLLIN, 0};
    poll_args.push_back(pfd);

    for(Conn* conn:fd2conn){
      if(!conn) continue;
      struct pollfd pfd = {conn->fd,POLLERR,0};

      if(conn->want_read){
        pfd.events |= POLLIN;
      }
      if(conn->want_write){
        pfd.events |= POLLOUT;
      }
      poll_args.push_back(pfd);
    }

    int rv = poll(poll_args.data(),(nfds_t)poll_args.size(),-1);
    if(rv<0 && errno == EINTR) continue;
    if(rv<0) die("poll");

    if(poll_args[0].revents){
      if(Conn* conn = handle_accept(fd)){
        // if(fd2conn_map.size() <= (size_t)conn->fd){
        //   fd2conn_map.resize(conn->fd+1); // array Expansion
        //   //Q: Why is an array chosen for key-value saving?
        //   //A: fd is a dense integer that Increments starting from 0
        // }
        assert(!fd2conn[conn->fd]); // ensure fd is unique
        fd2conn[conn->fd] = conn;
      }
    }

    //handle connection sockets
    for(size_t i=1;i<poll_args.size();++i){ //skip 1st socket
      uint32_t ready = poll_args[i].revents;
      if(ready == 0) continue;

      Conn *conn = fd2conn[poll_args[i].fd];
      if(ready & POLLIN){  
        assert(conn->want_read);
        handle_read(conn);
      }
      if(ready & POLLOUT){ 
        assert(conn->want_write);
        handle_write(conn);
      }

      if((ready & POLLERR) || conn->want_close){
        (void)close(conn->fd);
        fd2conn[conn->fd]=NULL;
        delete conn;
      }
    }
  }



  // 清理Winsock
  closesocket(fd);
  WSACleanup();
  return 0;
}